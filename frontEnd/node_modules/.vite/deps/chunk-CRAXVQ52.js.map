{
  "version": 3,
  "sources": ["../../@loaders.gl/schema/dist/lib/table/simple-table/row-utils.js", "../../@loaders.gl/schema/dist/lib/table/batches/base-table-batch-aggregator.js", "../../@loaders.gl/schema/dist/lib/table/batches/row-table-batch-aggregator.js", "../../@loaders.gl/schema/dist/lib/table/batches/columnar-table-batch-aggregator.js", "../../@loaders.gl/schema/dist/lib/table/batches/table-batch-builder.js", "../../@loaders.gl/schema/dist/lib/table/simple-table/table-accessors.js", "../../@loaders.gl/schema/dist/lib/table/simple-table/make-table-from-batches.js", "../../@loaders.gl/schema/dist/lib/utils/async-queue.js", "../../@loaders.gl/schema/dist/lib/table/simple-table/data-type.js", "../../@loaders.gl/schema/dist/lib/table/simple-table/table-schema.js", "../../@loaders.gl/schema/dist/lib/mesh/mesh-utils.js", "../../@loaders.gl/schema/dist/lib/mesh/deduce-mesh-schema.js", "../../@loaders.gl/schema/dist/lib/table/arrow-api/enum.js"],
  "sourcesContent": ["// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n/** Convert an object row to an array row */\nexport function convertToObjectRow(arrayRow, headers) {\n    if (!arrayRow) {\n        throw new Error('null row');\n    }\n    const objectRow = {};\n    if (headers) {\n        for (let i = 0; i < headers.length; i++) {\n            objectRow[headers[i]] = arrayRow[i];\n        }\n    }\n    else {\n        for (let i = 0; i < arrayRow.length; i++) {\n            const columnName = `column-${i}`;\n            objectRow[columnName] = arrayRow[i];\n        }\n    }\n    return objectRow;\n}\n/** Convert an object row to an array row */\nexport function convertToArrayRow(objectRow, headers) {\n    if (!objectRow) {\n        throw new Error('null row');\n    }\n    if (headers) {\n        const arrayRow = new Array(headers.length);\n        for (let i = 0; i < headers.length; i++) {\n            arrayRow[i] = objectRow[headers[i]];\n        }\n        return arrayRow;\n    }\n    return Object.values(objectRow);\n}\n/** Get headers from a sample array row */\nexport function inferHeadersFromArrayRow(arrayRow) {\n    const headers = [];\n    for (let i = 0; i < arrayRow.length; i++) {\n        const columnName = `column-${i}`;\n        headers.push(columnName);\n    }\n    return headers;\n}\n/** Get headers from a smaple object row */\nexport function inferHeadersFromObjectRow(row) {\n    return Object.keys(row);\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nconst DEFAULT_ROW_COUNT = 100;\nexport class BaseTableBatchAggregator {\n    schema;\n    options;\n    shape;\n    length = 0;\n    rows = null;\n    cursor = 0;\n    _headers = [];\n    constructor(schema, options) {\n        this.options = options;\n        this.schema = schema;\n        // schema is an array if there're no headers\n        // object if there are headers\n        if (!Array.isArray(schema)) {\n            this._headers = [];\n            for (const key in schema) {\n                this._headers[schema[key].index] = schema[key].name;\n            }\n        }\n    }\n    rowCount() {\n        return this.length;\n    }\n    addArrayRow(row, cursor) {\n        if (Number.isFinite(cursor)) {\n            this.cursor = cursor;\n        }\n        this.shape = 'array-row-table';\n        this.rows = this.rows || new Array(DEFAULT_ROW_COUNT);\n        this.rows[this.length] = row;\n        this.length++;\n    }\n    addObjectRow(row, cursor) {\n        if (Number.isFinite(cursor)) {\n            this.cursor = cursor;\n        }\n        this.shape = 'object-row-table';\n        this.rows = this.rows || new Array(DEFAULT_ROW_COUNT);\n        this.rows[this.length] = row;\n        this.length++;\n    }\n    getBatch() {\n        let rows = this.rows;\n        if (!rows) {\n            return null;\n        }\n        rows = rows.slice(0, this.length);\n        this.rows = null;\n        const batch = {\n            shape: this.shape || 'array-row-table',\n            batchType: 'data',\n            data: rows,\n            length: this.length,\n            schema: this.schema,\n            cursor: this.cursor\n        };\n        return batch;\n    }\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { convertToArrayRow, convertToObjectRow, inferHeadersFromArrayRow, inferHeadersFromObjectRow } from \"../simple-table/row-utils.js\";\nconst DEFAULT_ROW_COUNT = 100;\nexport class RowTableBatchAggregator {\n    schema;\n    options;\n    length = 0;\n    objectRows = null;\n    arrayRows = null;\n    cursor = 0;\n    _headers = null;\n    constructor(schema, options) {\n        this.options = options;\n        this.schema = schema;\n        // schema is an array if there're no headers\n        // object if there are headers\n        if (schema) {\n            this._headers = [];\n            for (const key in schema) {\n                this._headers[schema[key].index] = schema[key].name;\n            }\n        }\n    }\n    rowCount() {\n        return this.length;\n    }\n    addArrayRow(row, cursor) {\n        if (Number.isFinite(cursor)) {\n            this.cursor = cursor;\n        }\n        // TODO - infer schema at a higher level, instead of hacking headers here?\n        this._headers ||= inferHeadersFromArrayRow(row);\n        // eslint-disable-next-line default-case\n        switch (this.options.shape) {\n            case 'object-row-table':\n                const rowObject = convertToObjectRow(row, this._headers);\n                this.addObjectRow(rowObject, cursor);\n                break;\n            case 'array-row-table':\n                this.arrayRows = this.arrayRows || new Array(DEFAULT_ROW_COUNT);\n                this.arrayRows[this.length] = row;\n                this.length++;\n                break;\n        }\n    }\n    addObjectRow(row, cursor) {\n        if (Number.isFinite(cursor)) {\n            this.cursor = cursor;\n        }\n        // TODO - infer schema at a higher level, instead of hacking headers here?\n        this._headers ||= inferHeadersFromObjectRow(row);\n        // eslint-disable-next-line default-case\n        switch (this.options.shape) {\n            case 'array-row-table':\n                const rowArray = convertToArrayRow(row, this._headers);\n                this.addArrayRow(rowArray, cursor);\n                break;\n            case 'object-row-table':\n                this.objectRows = this.objectRows || new Array(DEFAULT_ROW_COUNT);\n                this.objectRows[this.length] = row;\n                this.length++;\n                break;\n        }\n    }\n    getBatch() {\n        let rows = this.arrayRows || this.objectRows;\n        if (!rows) {\n            return null;\n        }\n        rows = rows.slice(0, this.length);\n        this.arrayRows = null;\n        this.objectRows = null;\n        return {\n            shape: this.options.shape,\n            batchType: 'data',\n            data: rows,\n            length: this.length,\n            // @ts-expect-error we should infer a schema\n            schema: this.schema,\n            cursor: this.cursor\n        };\n    }\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nconst DEFAULT_ROW_COUNT = 100;\nexport class ColumnarTableBatchAggregator {\n    schema;\n    length = 0;\n    allocated = 0;\n    columns = {};\n    constructor(schema, options) {\n        this.schema = schema;\n        this._reallocateColumns();\n    }\n    rowCount() {\n        return this.length;\n    }\n    addArrayRow(row) {\n        // If user keeps pushing rows beyond batch size, reallocate\n        this._reallocateColumns();\n        let i = 0;\n        // TODO what if no csv header, columns not populated?\n        for (const fieldName in this.columns) {\n            this.columns[fieldName][this.length] = row[i++];\n        }\n        this.length++;\n    }\n    addObjectRow(row) {\n        // If user keeps pushing rows beyond batch size, reallocate\n        this._reallocateColumns();\n        for (const fieldName in row) {\n            this.columns[fieldName][this.length] = row[fieldName];\n        }\n        this.length++;\n    }\n    getBatch() {\n        this._pruneColumns();\n        const columns = Array.isArray(this.schema) ? this.columns : {};\n        // schema is an array if there're no headers\n        // object if there are headers\n        // columns should match schema format\n        if (!Array.isArray(this.schema)) {\n            for (const fieldName in this.schema) {\n                const field = this.schema[fieldName];\n                columns[field.name] = this.columns[field.index];\n            }\n        }\n        this.columns = {};\n        const batch = {\n            shape: 'columnar-table',\n            batchType: 'data',\n            data: columns,\n            schema: this.schema,\n            length: this.length\n        };\n        return batch;\n    }\n    // HELPERS\n    _reallocateColumns() {\n        if (this.length < this.allocated) {\n            return;\n        }\n        // @ts-ignore TODO\n        this.allocated = this.allocated > 0 ? (this.allocated *= 2) : DEFAULT_ROW_COUNT;\n        this.columns = {};\n        for (const fieldName in this.schema) {\n            const field = this.schema[fieldName];\n            const ArrayType = field.type || Float32Array;\n            const oldColumn = this.columns[field.index];\n            if (oldColumn && ArrayBuffer.isView(oldColumn)) {\n                // Copy the old data to the new array\n                const typedArray = new ArrayType(this.allocated);\n                typedArray.set(oldColumn);\n                this.columns[field.index] = typedArray;\n            }\n            else if (oldColumn) {\n                // Plain array\n                oldColumn.length = this.allocated;\n                this.columns[field.index] = oldColumn;\n            }\n            else {\n                // Create new\n                this.columns[field.index] = new ArrayType(this.allocated);\n            }\n        }\n    }\n    _pruneColumns() {\n        for (const [columnName, column] of Object.entries(this.columns)) {\n            this.columns[columnName] = column.slice(0, this.length);\n        }\n    }\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { BaseTableBatchAggregator } from \"./base-table-batch-aggregator.js\";\nimport { RowTableBatchAggregator } from \"./row-table-batch-aggregator.js\";\nimport { ColumnarTableBatchAggregator } from \"./columnar-table-batch-aggregator.js\";\nconst DEFAULT_OPTIONS = {\n    shape: undefined,\n    batchSize: 'auto',\n    batchDebounceMs: 0,\n    limit: 0,\n    _limitMB: 0\n};\nconst ERR_MESSAGE = 'TableBatchBuilder';\n/** Incrementally builds batches from a stream of rows */\nexport class TableBatchBuilder {\n    schema;\n    options;\n    aggregator = null;\n    batchCount = 0;\n    bytesUsed = 0;\n    isChunkComplete = false;\n    lastBatchEmittedMs = Date.now();\n    totalLength = 0;\n    totalBytes = 0;\n    rowBytes = 0;\n    static ArrowBatch;\n    constructor(schema, options) {\n        this.schema = schema;\n        this.options = { ...DEFAULT_OPTIONS, ...options };\n    }\n    limitReached() {\n        if (Boolean(this.options?.limit) && this.totalLength >= this.options.limit) {\n            return true;\n        }\n        if (Boolean(this.options?._limitMB) && this.totalBytes / 1e6 >= this.options._limitMB) {\n            return true;\n        }\n        return false;\n    }\n    /** @deprecated Use addArrayRow or addObjectRow */\n    addRow(row) {\n        if (this.limitReached()) {\n            return;\n        }\n        this.totalLength++;\n        this.rowBytes = this.rowBytes || this._estimateRowMB(row);\n        this.totalBytes += this.rowBytes;\n        if (Array.isArray(row)) {\n            this.addArrayRow(row);\n        }\n        else {\n            this.addObjectRow(row);\n        }\n    }\n    /** Add one row to the batch */\n    addArrayRow(row) {\n        if (!this.aggregator) {\n            const TableBatchType = this._getTableBatchType();\n            this.aggregator = new TableBatchType(this.schema, this.options);\n        }\n        this.aggregator.addArrayRow(row);\n    }\n    /** Add one row to the batch */\n    addObjectRow(row) {\n        if (!this.aggregator) {\n            const TableBatchType = this._getTableBatchType();\n            this.aggregator = new TableBatchType(this.schema, this.options);\n        }\n        this.aggregator.addObjectRow(row);\n    }\n    /** Mark an incoming raw memory chunk has completed */\n    chunkComplete(chunk) {\n        if (chunk instanceof ArrayBuffer) {\n            this.bytesUsed += chunk.byteLength;\n        }\n        if (typeof chunk === 'string') {\n            this.bytesUsed += chunk.length;\n        }\n        this.isChunkComplete = true;\n    }\n    getFullBatch(options) {\n        return this._isFull() ? this._getBatch(options) : null;\n    }\n    getFinalBatch(options) {\n        return this._getBatch(options);\n    }\n    // INTERNAL\n    _estimateRowMB(row) {\n        return Array.isArray(row) ? row.length * 8 : Object.keys(row).length * 8;\n    }\n    _isFull() {\n        // No batch, not ready\n        if (!this.aggregator || this.aggregator.rowCount() === 0) {\n            return false;\n        }\n        // if batchSize === 'auto' we wait for chunk to complete\n        // if batchSize === number, ensure we have enough rows\n        if (this.options.batchSize === 'auto') {\n            if (!this.isChunkComplete) {\n                return false;\n            }\n        }\n        else if (this.options.batchSize > this.aggregator.rowCount()) {\n            return false;\n        }\n        // Debounce batches\n        if (this.options.batchDebounceMs > Date.now() - this.lastBatchEmittedMs) {\n            return false;\n        }\n        // Emit batch\n        this.isChunkComplete = false;\n        this.lastBatchEmittedMs = Date.now();\n        return true;\n    }\n    /**\n     * bytesUsed can be set via chunkComplete or via getBatch*\n     */\n    _getBatch(options) {\n        if (!this.aggregator) {\n            return null;\n        }\n        // TODO - this can overly increment bytes used?\n        if (options?.bytesUsed) {\n            this.bytesUsed = options.bytesUsed;\n        }\n        const normalizedBatch = this.aggregator.getBatch();\n        normalizedBatch.count = this.batchCount;\n        normalizedBatch.bytesUsed = this.bytesUsed;\n        Object.assign(normalizedBatch, options);\n        this.batchCount++;\n        this.aggregator = null;\n        return normalizedBatch;\n    }\n    _getTableBatchType() {\n        switch (this.options.shape) {\n            case 'array-row-table':\n            case 'object-row-table':\n                return RowTableBatchAggregator;\n            case 'columnar-table':\n                return ColumnarTableBatchAggregator;\n            case 'arrow-table':\n                if (!TableBatchBuilder.ArrowBatch) {\n                    throw new Error(ERR_MESSAGE);\n                }\n                return TableBatchBuilder.ArrowBatch;\n            default:\n                return BaseTableBatchAggregator;\n        }\n    }\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nexport function isTable(table) {\n    const shape = typeof table === 'object' && table?.shape;\n    switch (shape) {\n        case 'array-row-table':\n        case 'object-row-table':\n            return Array.isArray(table.data);\n        case 'geojson-table':\n            return Array.isArray(table.features);\n        case 'columnar-table':\n            return table.data && typeof table.data === 'object';\n        case 'arrow-table':\n            return Boolean(table?.data?.numRows !== undefined);\n        default:\n            return false;\n    }\n}\n/**\n * Returns the length of the table (i.e. the number of rows)\n */\nexport function getTableLength(table) {\n    switch (table.shape) {\n        case 'array-row-table':\n        case 'object-row-table':\n            return table.data.length;\n        case 'geojson-table':\n            return table.features.length;\n        case 'arrow-table':\n            const arrowTable = table.data;\n            return arrowTable.numRows;\n        case 'columnar-table':\n            for (const column of Object.values(table.data)) {\n                return column.length || 0;\n            }\n            return 0;\n        default:\n            throw new Error('table');\n    }\n}\n/**\n * Returns the number of columns in the table\n * @throws Fails to deduce number of columns if the table has no schema and is empty\n */\nexport function getTableNumCols(table) {\n    if (table.schema) {\n        return table.schema.fields.length;\n    }\n    if (getTableLength(table) === 0) {\n        throw new Error('empty table');\n    }\n    switch (table.shape) {\n        case 'array-row-table':\n            return table.data[0].length;\n        case 'object-row-table':\n            return Object.keys(table.data[0]).length;\n        case 'geojson-table':\n            return Object.keys(table.features[0]).length;\n        case 'columnar-table':\n            return Object.keys(table.data).length;\n        case 'arrow-table':\n            const arrowTable = table.data;\n            return arrowTable.numCols;\n        default:\n            throw new Error('table');\n    }\n}\n/** Get a table cell value at row index and column name */\nexport function getTableCell(table, rowIndex, columnName) {\n    switch (table.shape) {\n        case 'array-row-table':\n            const columnIndex = getTableColumnIndex(table, columnName);\n            return table.data[rowIndex][columnIndex];\n        case 'object-row-table':\n            return table.data[rowIndex][columnName];\n        case 'geojson-table':\n            return table.features[rowIndex][columnName];\n        case 'columnar-table':\n            const column = table.data[columnName];\n            return column[rowIndex];\n        case 'arrow-table':\n            const arrowTable = table.data;\n            const arrowColumnIndex = arrowTable.schema.fields.findIndex((field) => field.name === columnName);\n            return arrowTable.getChildAt(arrowColumnIndex)?.get(rowIndex);\n        default:\n            throw new Error('todo');\n    }\n}\n/** Get a table cell value at row index and column name */\nexport function getTableCellAt(table, rowIndex, columnIndex) {\n    switch (table.shape) {\n        case 'array-row-table':\n            return table.data[rowIndex][columnIndex];\n        case 'object-row-table':\n            const columnName1 = getTableColumnName(table, columnIndex);\n            return table.data[rowIndex][columnName1];\n        case 'geojson-table':\n            const columnName2 = getTableColumnName(table, columnIndex);\n            return table.features[rowIndex][columnName2];\n        case 'columnar-table':\n            const columnName3 = getTableColumnName(table, columnIndex);\n            const column = table.data[columnName3];\n            return column[rowIndex];\n        case 'arrow-table':\n            const arrowTable = table.data;\n            return arrowTable.getChildAt(columnIndex)?.get(rowIndex);\n        default:\n            throw new Error('todo');\n    }\n}\n/** Deduce the table row shape */\nexport function getTableRowShape(table) {\n    switch (table.shape) {\n        case 'array-row-table':\n        case 'object-row-table':\n            return table.shape;\n        case 'geojson-table':\n            // TODO - this is not correct, geojson-table is not a row table\n            return 'object-row-table';\n        case 'columnar-table':\n        default:\n            throw new Error('Not a row table');\n    }\n}\n/** Get the index of a named table column. Requires the table to have a schema */\nexport function getTableColumnIndex(table, columnName) {\n    const columnIndex = table.schema?.fields.findIndex((field) => field.name === columnName);\n    if (columnIndex === undefined) {\n        throw new Error(columnName);\n    }\n    return columnIndex;\n}\n/** Get the name of a table column by index. Requires the table to have a schema */\nexport function getTableColumnName(table, columnIndex) {\n    const columnName = table.schema?.fields[columnIndex]?.name;\n    if (!columnName) {\n        throw new Error(`${columnIndex}`);\n    }\n    return columnName;\n}\n/**\n * Returns one row of the table in object format.\n * @param target Optional parameter will be used if needed to store the row. Can be reused between calls to improve performance\n * @returns an array representing the row. May be the original array in the row, a new object, or the target parameter\n */\n// eslint-disable-next-line complexity\nexport function getTableRowAsObject(table, rowIndex, target, copy) {\n    switch (table.shape) {\n        case 'object-row-table':\n            return copy ? Object.fromEntries(Object.entries(table.data[rowIndex])) : table.data[rowIndex];\n        case 'array-row-table':\n            if (table.schema) {\n                const objectRow = target || {};\n                for (let i = 0; i < table.schema.fields.length; i++) {\n                    objectRow[table.schema.fields[i].name] = table.data[rowIndex][i];\n                }\n                return objectRow;\n            }\n            throw new Error('no schema');\n        case 'geojson-table':\n            if (table.schema) {\n                const objectRow = target || {};\n                // TODO - should lift properties to top level\n                for (let i = 0; i < table.schema.fields.length; i++) {\n                    objectRow[table.schema.fields[i].name] = table.features[rowIndex][i];\n                }\n                return objectRow;\n            }\n            throw new Error('no schema');\n        case 'columnar-table':\n            if (table.schema) {\n                const objectRow = target || {};\n                for (let i = 0; i < table.schema.fields.length; i++) {\n                    objectRow[table.schema.fields[i].name] =\n                        table.data[table.schema.fields[i].name][rowIndex];\n                }\n                return objectRow;\n            }\n            else {\n                // eslint-disable-line no-else-return\n                const objectRow = target || {};\n                for (const [name, column] of Object.entries(table.data)) {\n                    objectRow[name] = column[rowIndex];\n                }\n                return objectRow;\n            }\n        case 'arrow-table':\n            const arrowTable = table.data;\n            const objectRow = target || {};\n            const row = arrowTable.get(rowIndex);\n            const schema = arrowTable.schema;\n            for (let i = 0; i < schema.fields.length; i++) {\n                objectRow[schema.fields[i].name] = row?.[schema.fields[i].name];\n            }\n            return objectRow;\n        default:\n            throw new Error('shape');\n    }\n}\n/**\n * Returns one row of the table in array format.\n * @param target Optional parameter will be used if needed to store the row. Can be reused between calls to improve performance.\n * @returns an array representing the row. May be the original array in the row, a new object, or the target parameter\n */\n// eslint-disable-next-line complexity\nexport function getTableRowAsArray(table, rowIndex, target, copy) {\n    switch (table.shape) {\n        case 'array-row-table':\n            return copy ? Array.from(table.data[rowIndex]) : table.data[rowIndex];\n        case 'object-row-table':\n            if (table.schema) {\n                const arrayRow = target || [];\n                for (let i = 0; i < table.schema.fields.length; i++) {\n                    arrayRow[i] = table.data[rowIndex][table.schema.fields[i].name];\n                }\n                return arrayRow;\n            }\n            // Warning: just slap on the values, this risks mismatches between rows\n            return Object.values(table.data[rowIndex]);\n        case 'geojson-table':\n            if (table.schema) {\n                const arrayRow = target || [];\n                // TODO - should lift properties to top level\n                for (let i = 0; i < table.schema.fields.length; i++) {\n                    arrayRow[i] = table.features[rowIndex][table.schema.fields[i].name];\n                }\n                return arrayRow;\n            }\n            // Warning: just slap on the values, this risks mismatches between rows\n            return Object.values(table.features[rowIndex]);\n        case 'columnar-table':\n            if (table.schema) {\n                const arrayRow = target || [];\n                for (let i = 0; i < table.schema.fields.length; i++) {\n                    arrayRow[i] = table.data[table.schema.fields[i].name][rowIndex];\n                }\n                return arrayRow;\n            }\n            else {\n                // eslint-disable-line no-else-return\n                const arrayRow = target || [];\n                let i = 0;\n                for (const column of Object.values(table.data)) {\n                    arrayRow[i] = column[rowIndex];\n                    i++;\n                }\n                return arrayRow;\n            }\n        case 'arrow-table':\n            const arrowTable = table.data;\n            const arrayRow = target || [];\n            const row = arrowTable.get(rowIndex);\n            const schema = arrowTable.schema;\n            for (let i = 0; i < schema.fields.length; i++) {\n                arrayRow[i] = row?.[schema.fields[i].name];\n            }\n            return arrayRow;\n        default:\n            throw new Error('shape');\n    }\n}\n/** Convert any table into array row format */\nexport function makeArrayRowTable(table) {\n    if (table.shape === 'array-row-table') {\n        return table;\n    }\n    const length = getTableLength(table);\n    const data = new Array(length);\n    for (let rowIndex = 0; rowIndex < length; rowIndex++) {\n        data[rowIndex] = getTableRowAsArray(table, rowIndex);\n    }\n    return {\n        shape: 'array-row-table',\n        schema: table.schema,\n        data\n    };\n}\n/** Convert any table into object row format */\nexport function makeObjectRowTable(table) {\n    if (table.shape === 'object-row-table') {\n        return table;\n    }\n    const length = getTableLength(table);\n    const data = new Array(length);\n    for (let rowIndex = 0; rowIndex < length; rowIndex++) {\n        data[rowIndex] = getTableRowAsObject(table, rowIndex);\n    }\n    return {\n        shape: 'object-row-table',\n        schema: table.schema,\n        data\n    };\n}\n/** Convert any table into object row format */\nexport function makeColumnarTable(table) {\n    if (table.shape === 'object-row-table') {\n        return table;\n    }\n    const length = getTableLength(table);\n    const data = new Array(length);\n    for (let rowIndex = 0; rowIndex < length; rowIndex++) {\n        data[rowIndex] = getTableRowAsObject(table, rowIndex);\n    }\n    return {\n        shape: 'object-row-table',\n        schema: table.schema,\n        data\n    };\n}\n// Row Iterators\n/**\n * Iterate over table rows\n * @param table\n * @param shape\n */\nexport function* makeRowIterator(table, shape) {\n    switch (shape) {\n        case 'array-row-table':\n            yield* makeArrayRowIterator(table);\n            break;\n        case 'object-row-table':\n            yield* makeObjectRowIterator(table);\n            break;\n        default:\n            throw new Error(`Unknown row type ${shape}`);\n    }\n}\n/**\n * Streaming processing: Iterate over table, yielding array rows\n * @param table\n * @param shape\n */\nexport function* makeArrayRowIterator(table, target = []) {\n    const length = getTableLength(table);\n    for (let rowIndex = 0; rowIndex < length; rowIndex++) {\n        yield getTableRowAsArray(table, rowIndex, target);\n    }\n}\n/**\n * Streaming processing: Iterate over table, yielding object rows\n * @param table\n * @param shape\n */\nexport function* makeObjectRowIterator(table, target = {}) {\n    const length = getTableLength(table);\n    for (let rowIndex = 0; rowIndex < length; rowIndex++) {\n        yield getTableRowAsObject(table, rowIndex, target);\n    }\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { getTableLength } from \"./table-accessors.js\";\n/**\n * Returns an iterator that yields a single table as a sequence of batches.\n * @note Currently only a single batch is yielded.\n * @note All batches will have the same shape and schema as the original table.\n * @returns\n */\nexport function* makeBatchesFromTable(table) {\n    yield makeBatchFromTable(table);\n}\n/**\n * Returns a table packaged as a single table batch\n * @note The batch will have the same shape and schema as the original table.\n * @returns `null` if no batches are yielded by the async iterator\n */\nexport function makeBatchFromTable(table) {\n    return { ...table, length: getTableLength(table), batchType: 'data' };\n}\n/**\n * Assembles all batches from an async iterator into a single table.\n * @note All batches must have the same shape and schema\n * @param batchIterator\n * @returns `null` if no batches are yielded by the async iterator\n */\n// eslint-disable-next-line complexity\nexport async function makeTableFromBatches(batchIterator) {\n    let arrayRows;\n    let objectRows;\n    let features;\n    let shape = null;\n    let schema;\n    for await (const batch of batchIterator) {\n        shape = shape || batch.shape;\n        schema = schema || batch.schema;\n        switch (batch.shape) {\n            case 'array-row-table':\n                arrayRows = arrayRows || [];\n                for (let rowIndex = 0; rowIndex < getTableLength(batch); rowIndex++) {\n                    const row = batch.data[rowIndex];\n                    arrayRows.push(row);\n                }\n                break;\n            case 'object-row-table':\n                objectRows = objectRows || [];\n                for (let rowIndex = 0; rowIndex < getTableLength(batch); rowIndex++) {\n                    const row = batch.data[rowIndex];\n                    objectRows.push(row);\n                }\n                break;\n            case 'geojson-table':\n                features = features || [];\n                for (let rowIndex = 0; rowIndex < getTableLength(batch); rowIndex++) {\n                    const row = batch.features[rowIndex];\n                    features.push(row);\n                }\n                break;\n            case 'columnar-table':\n            case 'arrow-table':\n            default:\n                throw new Error('shape');\n        }\n    }\n    if (!shape) {\n        return null;\n    }\n    switch (shape) {\n        case 'array-row-table':\n            return { shape: 'array-row-table', data: arrayRows, schema };\n        case 'object-row-table':\n            return { shape: 'object-row-table', data: objectRows, schema };\n        case 'geojson-table':\n            return { shape: 'geojson-table', type: 'FeatureCollection', features: features, schema };\n        default:\n            return null;\n    }\n}\n", "// From https://github.com/rauschma/async-iter-demo/tree/master/src under MIT license\n// http://2ality.com/2016/10/asynchronous-iteration.html\nclass ArrayQueue extends Array {\n    enqueue(value) {\n        // Add at the end\n        return this.push(value);\n    }\n    dequeue() {\n        // Remove first element\n        return this.shift();\n    }\n}\nexport default class AsyncQueue {\n    _values;\n    _settlers;\n    _closed;\n    constructor() {\n        // enqueues > dequeues\n        this._values = new ArrayQueue();\n        // dequeues > enqueues\n        this._settlers = new ArrayQueue();\n        this._closed = false;\n    }\n    close() {\n        while (this._settlers.length > 0) {\n            this._settlers.dequeue().resolve({ done: true });\n        }\n        this._closed = true;\n    }\n    [Symbol.asyncIterator]() {\n        return this;\n    }\n    enqueue(value) {\n        if (this._closed) {\n            throw new Error('Closed');\n        }\n        if (this._settlers.length > 0) {\n            if (this._values.length > 0) {\n                throw new Error('Illegal internal state');\n            }\n            const settler = this._settlers.dequeue();\n            if (value instanceof Error) {\n                settler.reject(value);\n            }\n            else {\n                settler.resolve({ value });\n            }\n        }\n        else {\n            this._values.enqueue(value);\n        }\n    }\n    /**\n     * @returns a Promise for an IteratorResult\n     */\n    next() {\n        if (this._values.length > 0) {\n            const value = this._values.dequeue();\n            if (value instanceof Error) {\n                return Promise.reject(value);\n            }\n            return Promise.resolve({ value });\n        }\n        if (this._closed) {\n            if (this._settlers.length > 0) {\n                throw new Error('Illegal internal state');\n            }\n            return Promise.resolve({ done: true });\n        }\n        // Wait for new values to be enqueued\n        return new Promise((resolve, reject) => {\n            this._settlers.enqueue({ resolve, reject });\n        });\n    }\n}\n/**\n * @returns a Promise for an Array with the elements in `asyncIterable`\n */\nexport async function takeAsync(asyncIterable, count = Infinity) {\n    const result = [];\n    const iterator = asyncIterable[Symbol.asyncIterator]();\n    while (result.length < count) {\n        const { value, done } = await iterator.next();\n        if (done) {\n            break;\n        }\n        result.push(value);\n    }\n    return result;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n/** Deduce column types from values */\nexport function getDataTypeFromValue(value, defaultNumberType = 'float32') {\n    if (value instanceof Date) {\n        return 'date-millisecond';\n    }\n    if (value instanceof Number) {\n        return defaultNumberType;\n    }\n    if (typeof value === 'string') {\n        return 'utf8';\n    }\n    if (value === null || value === 'undefined') {\n        return 'null';\n    }\n    return 'null';\n}\n/**\n * Deduces a simple data type \"descriptor from a typed array instance\n */\nexport function getDataTypeFromArray(array) {\n    let type = getDataTypeFromTypedArray(array);\n    if (type !== 'null') {\n        return { type, nullable: false };\n    }\n    if (array.length > 0) {\n        type = getDataTypeFromValue(array[0]);\n        return { type, nullable: true };\n    }\n    return { type: 'null', nullable: true };\n}\n/**\n * Deduces a simple data type \"descriptor from a typed array instance\n */\nexport function getDataTypeFromTypedArray(array) {\n    switch (array.constructor) {\n        case Int8Array:\n            return 'int8';\n        case Uint8Array:\n        case Uint8ClampedArray:\n            return 'uint8';\n        case Int16Array:\n            return 'int16';\n        case Uint16Array:\n            return 'uint16';\n        case Int32Array:\n            return 'int32';\n        case Uint32Array:\n            return 'uint32';\n        case Float32Array:\n            return 'float32';\n        case Float64Array:\n            return 'float64';\n        default:\n            return 'null';\n    }\n}\nexport function getArrayTypeFromDataType(type, nullable) {\n    if (!nullable) {\n        switch (type) {\n            case 'int8':\n                return Int8Array;\n            case 'uint8':\n                return Uint8Array;\n            case 'int16':\n                return Int16Array;\n            case 'uint16':\n                return Uint16Array;\n            case 'int32':\n                return Int32Array;\n            case 'uint32':\n                return Uint32Array;\n            case 'float32':\n                return Float32Array;\n            case 'float64':\n                return Float64Array;\n            default:\n                break;\n        }\n    }\n    // if (typeof BigInt64Array !== 'undefined') {\n    //   TYPED_ARRAY_TO_TYPE.BigInt64Array = new Int64();\n    //   TYPED_ARRAY_TO_TYPE.BigUint64Array = new Uint64();\n    // }\n    return Array;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { getDataTypeFromArray, getDataTypeFromValue } from \"./data-type.js\";\n/**\n * SCHEMA SUPPORT - AUTODEDUCTION\n * @param {*} table\n * @param {*} schema\n * @returns\n */\nexport function deduceTableSchema(table) {\n    switch (table.shape) {\n        case 'array-row-table':\n        case 'object-row-table':\n            return deduceSchemaFromRows(table.data);\n        case 'geojson-table':\n            return deduceSchemaFromGeoJSON(table.features);\n        case 'columnar-table':\n            return deduceSchemaFromColumns(table.data);\n        case 'arrow-table':\n        default:\n            throw new Error('Deduce schema');\n    }\n}\nexport function deduceSchema(data) {\n    return Array.isArray(data) ? deduceSchemaFromRows(data) : deduceSchemaFromColumns(data);\n}\n/** Given an object with columnar arrays, try to deduce a schema */\nfunction deduceSchemaFromColumns(columnarTable) {\n    const fields = [];\n    for (const [columnName, column] of Object.entries(columnarTable)) {\n        const field = deduceFieldFromColumn(column, columnName);\n        fields.push(field);\n    }\n    return { fields, metadata: {} };\n}\n/** Given an array of rows, try to deduce a schema */\nfunction deduceSchemaFromRows(rowTable) {\n    if (!rowTable.length) {\n        throw new Error('deduce from empty table');\n    }\n    const fields = [];\n    const row0 = rowTable[0];\n    // TODO - fields can be nullable, false detection...\n    // Could look at additional rows if nulls in first row\n    // TODO - if array, column names will be numbers\n    for (const [columnName, value] of Object.entries(row0)) {\n        fields.push(deduceFieldFromValue(value, columnName));\n    }\n    return { fields, metadata: {} };\n}\n/** Given a GeoJSON, try to deduce a schema */\nfunction deduceSchemaFromGeoJSON(features) {\n    if (!features.length) {\n        throw new Error('deduce from empty table');\n    }\n    const fields = [];\n    const row0 = features[0].properties || {};\n    // TODO - fields can be nullable, false detection...\n    // Could look at additional rows if nulls in first row\n    // TODO - if array, column names will be numbers\n    for (const [columnName, value] of Object.entries(row0)) {\n        fields.push(deduceFieldFromValue(value, columnName));\n    }\n    return { fields, metadata: {} };\n}\n/** Given a column (i.e. array), attempt to deduce an appropriate `Field` */\nfunction deduceFieldFromColumn(column, name) {\n    if (ArrayBuffer.isView(column)) {\n        const type = getDataTypeFromArray(column);\n        return {\n            name,\n            type: type.type || 'null',\n            nullable: type.nullable\n            // metadata: {}\n        };\n    }\n    if (Array.isArray(column) && column.length > 0) {\n        const value = column[0];\n        const type = getDataTypeFromValue(value);\n        // TODO - support nested schemas?\n        return {\n            name,\n            type,\n            nullable: true\n            // metadata: {},\n        };\n    }\n    throw new Error('empty table');\n}\n/** Given a value, attempt to deduce an appropriate `Field` */\nfunction deduceFieldFromValue(value, name) {\n    const type = getDataTypeFromValue(value);\n    return {\n        name,\n        type,\n        nullable: true\n        // metadata: {}\n    };\n}\n", "/**\n * Get number of vertices in mesh\n * @param attributes\n */\nexport function getMeshSize(attributes) {\n    let size = 0;\n    for (const attributeName in attributes) {\n        const attribute = attributes[attributeName];\n        if (ArrayBuffer.isView(attribute)) {\n            // @ts-ignore DataView doesn't have BYTES_PER_ELEMENT\n            size += attribute.byteLength * attribute.BYTES_PER_ELEMENT;\n        }\n    }\n    return size;\n}\n/**\n * Get the (axis aligned) bounding box of a mesh\n * @param attributes\n * @returns array of two vectors representing the axis aligned bounding box\n */\n// eslint-disable-next-line complexity\nexport function getMeshBoundingBox(attributes) {\n    let minX = Infinity;\n    let minY = Infinity;\n    let minZ = Infinity;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n    let maxZ = -Infinity;\n    const positions = attributes.POSITION ? attributes.POSITION.value : [];\n    const len = positions && positions.length;\n    for (let i = 0; i < len; i += 3) {\n        const x = positions[i];\n        const y = positions[i + 1];\n        const z = positions[i + 2];\n        minX = x < minX ? x : minX;\n        minY = y < minY ? y : minY;\n        minZ = z < minZ ? z : minZ;\n        maxX = x > maxX ? x : maxX;\n        maxY = y > maxY ? y : maxY;\n        maxZ = z > maxZ ? z : maxZ;\n    }\n    return [\n        [minX, minY, minZ],\n        [maxX, maxY, maxZ]\n    ];\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { getDataTypeFromTypedArray } from \"../table/simple-table/data-type.js\";\n/**\n * Create a schema for mesh attributes data\n * @param attributes\n * @param metadata\n * @returns\n */\nexport function deduceMeshSchema(attributes, metadata = {}) {\n    const fields = deduceMeshFields(attributes);\n    return { fields, metadata };\n}\n/**\n * Create arrow-like schema field for mesh attribute\n * @param attributeName\n * @param attribute\n * @param optionalMetadata\n * @returns\n */\nexport function deduceMeshField(name, attribute, optionalMetadata) {\n    const type = getDataTypeFromTypedArray(attribute.value);\n    const metadata = optionalMetadata ? optionalMetadata : makeMeshAttributeMetadata(attribute);\n    return {\n        name,\n        type: { type: 'fixed-size-list', listSize: attribute.size, children: [{ name: 'value', type }] },\n        nullable: false,\n        metadata\n    };\n}\n/**\n * Create fields array for mesh attributes\n * @param attributes\n * @returns\n */\nfunction deduceMeshFields(attributes) {\n    const fields = [];\n    for (const attributeName in attributes) {\n        const attribute = attributes[attributeName];\n        fields.push(deduceMeshField(attributeName, attribute));\n    }\n    return fields;\n}\n/**\n * Make metadata by mesh attribute properties\n * @param attribute\n * @returns\n */\nexport function makeMeshAttributeMetadata(attribute) {\n    const result = {};\n    if ('byteOffset' in attribute) {\n        result.byteOffset = attribute.byteOffset.toString(10);\n    }\n    if ('byteStride' in attribute) {\n        result.byteStride = attribute.byteStride.toString(10);\n    }\n    if ('normalized' in attribute) {\n        result.normalized = attribute.normalized.toString();\n    }\n    return result;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// This code is adapted from ArrowJS https://github.com/apache/arrow\n// under Apache license http://www.apache.org/licenses/LICENSE-2.0\n/**\n * Main data type enumeration.\n *\n * Data types in this library are all *logical*. They can be expressed as\n * either a primitive physical type (bytes or bits of some fixed size), a\n * nested type consisting of other data types, or another data type (e.g. a\n * timestamp encoded as an int64).\n *\n * **Note**: Only enum values 0-17 (NONE through Map) are written to an Arrow\n * IPC payload.\n *\n * The rest of the values are specified here so TypeScript can narrow the type\n * signatures further beyond the base Arrow Types. The Arrow DataTypes include\n * metadata like `bitWidth` that impact the type signatures of the values we\n * accept and return.\n *\n * For example, the `Int8Vector` reads 1-byte numbers from an `Int8Array`, an\n * `Int32Vector` reads a 4-byte number from an `Int32Array`, and an `Int64Vector`\n * reads a pair of 4-byte lo, hi 32-bit integers as a zero-copy slice from the\n * underlying `Int32Array`.\n *\n * Library consumers benefit by knowing the narrowest type, since we can ensure\n * the types across all public methods are propagated, and never bail to `any`.\n * These values are _never_ used at runtime, and they will _never_ be written\n * to the flatbuffers metadata of serialized Arrow IPC payloads.\n */\nexport var Type;\n(function (Type) {\n    /** The default placeholder type */\n    Type[Type[\"NONE\"] = 0] = \"NONE\";\n    /** A NULL type having no physical storage */\n    Type[Type[\"Null\"] = 1] = \"Null\";\n    /** Signed or unsigned 8, 16, 32, or 64-bit little-endian integer */\n    Type[Type[\"Int\"] = 2] = \"Int\";\n    /** 2, 4, or 8-byte floating point value */\n    Type[Type[\"Float\"] = 3] = \"Float\";\n    /** Variable-length bytes (no guarantee of UTF8-ness) */\n    Type[Type[\"Binary\"] = 4] = \"Binary\";\n    /** UTF8 variable-length string as List<Char> */\n    Type[Type[\"Utf8\"] = 5] = \"Utf8\";\n    /** Boolean as 1 bit, LSB bit-packed ordering */\n    Type[Type[\"Bool\"] = 6] = \"Bool\";\n    /** Precision-and-scale-based decimal type. Storage type depends on the parameters. */\n    Type[Type[\"Decimal\"] = 7] = \"Decimal\";\n    /** int32_t days or int64_t milliseconds since the UNIX epoch */\n    Type[Type[\"Date\"] = 8] = \"Date\";\n    /** Time as signed 32 or 64-bit integer, representing either seconds, milliseconds, microseconds, or nanoseconds since midnight since midnight */\n    Type[Type[\"Time\"] = 9] = \"Time\";\n    /** Exact timestamp encoded with int64 since UNIX epoch (Default unit millisecond) */\n    Type[Type[\"Timestamp\"] = 10] = \"Timestamp\";\n    /** YEAR_MONTH or DAY_TIME interval in SQL style */\n    Type[Type[\"Interval\"] = 11] = \"Interval\";\n    /** A list of some logical data type */\n    Type[Type[\"List\"] = 12] = \"List\";\n    /** Struct of logical types */\n    Type[Type[\"Struct\"] = 13] = \"Struct\";\n    /** Union of logical types */\n    Type[Type[\"Union\"] = 14] = \"Union\";\n    /** Fixed-size binary. Each value occupies the same number of bytes */\n    Type[Type[\"FixedSizeBinary\"] = 15] = \"FixedSizeBinary\";\n    /** Fixed-size list. Each value occupies the same number of bytes */\n    Type[Type[\"FixedSizeList\"] = 16] = \"FixedSizeList\";\n    /** Map of named logical types */\n    Type[Type[\"Map\"] = 17] = \"Map\";\n    /** Dictionary aka Category type */\n    Type[Type[\"Dictionary\"] = -1] = \"Dictionary\";\n    Type[Type[\"Int8\"] = -2] = \"Int8\";\n    Type[Type[\"Int16\"] = -3] = \"Int16\";\n    Type[Type[\"Int32\"] = -4] = \"Int32\";\n    Type[Type[\"Int64\"] = -5] = \"Int64\";\n    Type[Type[\"Uint8\"] = -6] = \"Uint8\";\n    Type[Type[\"Uint16\"] = -7] = \"Uint16\";\n    Type[Type[\"Uint32\"] = -8] = \"Uint32\";\n    Type[Type[\"Uint64\"] = -9] = \"Uint64\";\n    Type[Type[\"Float16\"] = -10] = \"Float16\";\n    Type[Type[\"Float32\"] = -11] = \"Float32\";\n    Type[Type[\"Float64\"] = -12] = \"Float64\";\n    Type[Type[\"DateDay\"] = -13] = \"DateDay\";\n    Type[Type[\"DateMillisecond\"] = -14] = \"DateMillisecond\";\n    Type[Type[\"TimestampSecond\"] = -15] = \"TimestampSecond\";\n    Type[Type[\"TimestampMillisecond\"] = -16] = \"TimestampMillisecond\";\n    Type[Type[\"TimestampMicrosecond\"] = -17] = \"TimestampMicrosecond\";\n    Type[Type[\"TimestampNanosecond\"] = -18] = \"TimestampNanosecond\";\n    Type[Type[\"TimeSecond\"] = -19] = \"TimeSecond\";\n    Type[Type[\"TimeMillisecond\"] = -20] = \"TimeMillisecond\";\n    Type[Type[\"TimeMicrosecond\"] = -21] = \"TimeMicrosecond\";\n    Type[Type[\"TimeNanosecond\"] = -22] = \"TimeNanosecond\";\n    Type[Type[\"DenseUnion\"] = -23] = \"DenseUnion\";\n    Type[Type[\"SparseUnion\"] = -24] = \"SparseUnion\";\n    Type[Type[\"IntervalDayTime\"] = -25] = \"IntervalDayTime\";\n    Type[Type[\"IntervalYearMonth\"] = -26] = \"IntervalYearMonth\";\n})(Type || (Type = {}));\n"],
  "mappings": "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",
  "names": ["DEFAULT_ROW_COUNT", "DEFAULT_ROW_COUNT", "arrayRow", "Type"]
}
